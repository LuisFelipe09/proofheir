// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import {Test, console} from "forge-std/Test.sol";
import {MockERC20} from "../src/MockERC20.sol";
import {ProofHeir} from "../src/ProofHeir.sol";
import {HonkVerifier} from "../src/Verifier.sol";

/**
 * @title VerifierIntegrationTest
 * @notice Integration tests using the real HonkVerifier (ZK proof verification).
 * @dev Uses valid ZK proof generated by the Noir circuit.
 */
contract VerifierIntegrationTest is Test {
    MockERC20 public tokenA;
    ProofHeir public proofHeir;
    HonkVerifier public verifier;

    // Bob is the Testator (he has assets)
    address payable BOB_ADDRESS;
    uint256 BOB_PK = 0xB0B;
    
    // Alice is the Heir
    address ALICE_ADDRESS;

    // Constants matching the circuit
    string constant TRUSTED_SERVER_DOMAIN = "civil-registry-mock.onrender.com        ";
    bytes32 constant SERVER_HASH = 0x5ddeed97a3950919f49ab7e413eeb1272467a129b6a75b59ac81da0516bdfb92;
    bytes32 IDENTITY_COMMITMENT;

    function setUp() public {
        BOB_ADDRESS = payable(vm.addr(BOB_PK));
        ALICE_ADDRESS = vm.addr(0xA11CE);
        IDENTITY_COMMITMENT = keccak256("bob_identity_salt");

        tokenA = new MockERC20();
        
        // Deploy the REAL HonkVerifier
        verifier = new HonkVerifier();
        
        // Deploy ProofHeir with real verifier
        proofHeir = new ProofHeir(address(verifier), TRUSTED_SERVER_DOMAIN);

        tokenA.mint(BOB_ADDRESS, 1000);
    }

    /**
     * @notice Test that the HonkVerifier contract deploys correctly.
     */
    function testVerifierDeployment() public view {
        assertTrue(address(verifier) != address(0), "Verifier not deployed");
        console.log("Verifier contract deployed at:", address(verifier));
    }

    /**
     * @notice Test that ProofHeir correctly stores the server hash.
     */
    function testProofHeirInitialization() public view {
        assertEq(proofHeir.trustedServerHash(), SERVER_HASH, "Server hash mismatch");
        assertEq(address(proofHeir.verifier()), address(verifier), "Verifier mismatch");
    }

    /**
     * @notice Test that invalid proofs are rejected.
     */
    function testInvalidProofRejected() public {
        address[] memory tokens = new address[](1);
        tokens[0] = address(tokenA);

        bytes memory invalidProof = hex"deadbeef";
        bytes32[] memory publicInputs = new bytes32[](4);
        publicInputs[0] = bytes32(uint256(uint160(ALICE_ADDRESS)));
        publicInputs[1] = IDENTITY_COMMITMENT;
        publicInputs[2] = SERVER_HASH;
        publicInputs[3] = bytes32(uint256(0x999));

        vm.signAndAttachDelegation(address(proofHeir), BOB_PK);
        
        vm.prank(BOB_ADDRESS);
        ProofHeir(BOB_ADDRESS).registerIdentity(IDENTITY_COMMITMENT);

        vm.startPrank(ALICE_ADDRESS);
        vm.expectRevert();
        ProofHeir(BOB_ADDRESS).proveDeathAndRegisterHeir(invalidProof, publicInputs);
        vm.stopPrank();
    }

    /**
     * @notice Test with a real valid ZK proof generated from the circuit.
     * @dev Proof generated with bb prove (ultra_honk + keccak oracle)
     *      recipient: 0x03f72d5859858AFF7b93096B4AD9593442DD2327
     *      nuip: "123" (padded to 15 chars)
     *      salt: 5b635e98e5875da7a0f482b9fb3af8f0e9e3b070997f904f4020d783ca82e503
     */
    function testValidProofVerification() public view {
        bytes memory proof = vm.readFileBinary("test/fixtures/proof");
        bytes32[] memory publicInputs = _buildPublicInputs();
        
        console.log("Proof length:", proof.length);
        console.log("Public inputs count:", publicInputs.length);
        
        bool result = verifier.verify(proof, publicInputs);
        assertTrue(result, "Valid proof should verify");
    }

    /**
     * @notice Full end-to-end test: EIP-7702 delegation + ZK proof verification + asset claim.
     */
    function testFullClaimWithRealProof() public {
        bytes memory proof = vm.readFileBinary("test/fixtures/proof");
        bytes32[] memory publicInputs = _buildPublicInputs();
        
        // ID commitment from sha256(nuip || salt) where nuip="123" (padded to 15) and salt=5b635e98...
        bytes32 idCommitment = _extractBytes32FromPublicInputs(publicInputs, 52);
        
        // The recipient in the proof
        address proofRecipient = 0x03f72d5859858AFF7b93096B4AD9593442DD2327;
        
        address[] memory tokens = new address[](1);
        tokens[0] = address(tokenA);
        
        // EIP-7702: Bob delegates his account to ProofHeir implementation
        vm.signAndAttachDelegation(address(proofHeir), BOB_PK);
        
        // Bob registers his identity commitment
        vm.prank(BOB_ADDRESS);
        ProofHeir(BOB_ADDRESS).registerIdentity(idCommitment);
        
        assertEq(ProofHeir(BOB_ADDRESS).getIdentityCommitment(), idCommitment, "Identity not registered");
        assertEq(tokenA.balanceOf(BOB_ADDRESS), 1000, "Bob should have 1000 tokens");
        assertEq(tokenA.balanceOf(proofRecipient), 0, "Recipient should have 0 tokens initially");
        
        // Step 1: Register heir with valid ZK proof
        vm.prank(ALICE_ADDRESS);
        ProofHeir(BOB_ADDRESS).proveDeathAndRegisterHeir(proof, publicInputs);
        
        // Step 2: Claim and transfer tokens
        vm.prank(ALICE_ADDRESS);
        ProofHeir(BOB_ADDRESS).claimInheritance(tokens);
        
        assertEq(tokenA.balanceOf(BOB_ADDRESS), 0, "Bob should have 0 tokens after claim");
        assertEq(tokenA.balanceOf(proofRecipient), 1000, "Recipient should have 1000 tokens");
        
        console.log("Full end-to-end claim with real ZK proof succeeded!");
    }

    /**
     * @dev Helper to build public inputs array from Prover.toml values.
     *      Total: 116 fields (20 recipient + 32 server_hash + 32 id_commitment + 32 status_commitment)
     */
    function _buildPublicInputs() internal pure returns (bytes32[] memory) {
        bytes32[] memory publicInputs = new bytes32[](116);
        
        // Recipient: 0x03f72d5859858AFF7b93096B4AD9593442DD2327
        uint8[20] memory recipientBytes = [
            0x03, 0xf7, 0x2d, 0x58, 0x59, 0x85, 0x8a, 0xff, 0x7b, 0x93,
            0x09, 0x6b, 0x4a, 0xd9, 0x59, 0x34, 0x42, 0xdd, 0x23, 0x27
        ];
        for (uint i = 0; i < 20; i++) {
            publicInputs[i] = bytes32(uint256(recipientBytes[i]));
        }
        
        // Server Hash: 0x5ddeed97a3950919f49ab7e413eeb1272467a129b6a75b59ac81da0516bdfb92
        uint8[32] memory serverHashBytes = [
            0x5d, 0xde, 0xed, 0x97, 0xa3, 0x95, 0x09, 0x19, 0xf4, 0x9a, 0xb7, 0xe4, 0x13, 0xee, 0xb1, 0x27,
            0x24, 0x67, 0xa1, 0x29, 0xb6, 0xa7, 0x5b, 0x59, 0xac, 0x81, 0xda, 0x05, 0x16, 0xbd, 0xfb, 0x92
        ];
        for (uint i = 0; i < 32; i++) {
            publicInputs[20 + i] = bytes32(uint256(serverHashBytes[i]));
        }
        
        // ID Commitment: sha256(nuip || salt) = 0xbc3aa755f7a5766032261...
        uint8[32] memory idCommitmentBytes = [
            0xbc, 0x3a, 0xa7, 0x55, 0xf7, 0xa5, 0x76, 0x60, 0x32, 0x26, 0x12, 0xe3, 0x8b, 0x80, 0x7a, 0xbf,
            0xb6, 0xd4, 0xda, 0xfa, 0x11, 0xb0, 0x1d, 0x44, 0x8f, 0xc6, 0xc0, 0x36, 0x9d, 0xeb, 0xa1, 0x3e
        ];
        for (uint i = 0; i < 32; i++) {
            publicInputs[52 + i] = bytes32(uint256(idCommitmentBytes[i]));
        }
        
        // Status Commitment: sha256(status || blinder) = 0x7215deae275bac9a08b1...
        uint8[32] memory statusCommitmentBytes = [
            0x72, 0x15, 0xde, 0xae, 0x27, 0x5b, 0xac, 0x9a, 0x08, 0xb1, 0xc4, 0x8a, 0x13, 0xeb, 0xf9, 0xc2,
            0x43, 0x30, 0x73, 0x2d, 0xe0, 0x2f, 0x94, 0x70, 0x9f, 0xef, 0xcd, 0x8b, 0x0a, 0x9b, 0x75, 0xd8
        ];
        for (uint i = 0; i < 32; i++) {
            publicInputs[84 + i] = bytes32(uint256(statusCommitmentBytes[i]));
        }
        
        return publicInputs;
    }
    
    /**
     * @dev Helper to extract bytes32 from expanded public inputs
     */
    function _extractBytes32FromPublicInputs(bytes32[] memory inputs, uint256 startIndex) internal pure returns (bytes32) {
        bytes32 result;
        for (uint256 i = 0; i < 32; i++) {
            result |= bytes32(bytes1(uint8(uint256(inputs[startIndex + i])))) >> (i * 8);
        }
        return result;
    }
}
