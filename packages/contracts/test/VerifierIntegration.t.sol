// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import {Test, console} from "forge-std/Test.sol";
import {MockERC20} from "../src/MockERC20.sol";
import {ProofHeir} from "../src/ProofHeir.sol";
import {HonkVerifier} from "../src/Verifier.sol";

/**
 * @title VerifierIntegrationTest
 * @notice Integration tests using the real HonkVerifier (ZK proof verification).
 * @dev NOTE: These tests require a valid ZK proof generated by the Noir circuit.
 *      The proof generation (`bb prove`) was blocked by CLI version issues.
 *      For now, this test demonstrates the expected behavior and will fail
 *      until a valid proof is provided.
 */
contract VerifierIntegrationTest is Test {
    MockERC20 public tokenA;
    ProofHeir public proofHeir;
    HonkVerifier public verifier;

    // Bob is the Testator (he has assets)
    address payable BOB_ADDRESS;
    uint256 BOB_PK = 0xB0B;
    
    // Alice is the Heir
    address ALICE_ADDRESS;

    // Constants matching the circuit
    string constant TRUSTED_SERVER_DOMAIN = "civil-registry-mock.onrender.com        ";
    bytes32 constant SERVER_HASH = 0x5ddeed97a3950919f49ab7e413eeb1272467a129b6a75b59ac81da0516bdfb92;
    bytes32 IDENTITY_COMMITMENT;

    function setUp() public {
        BOB_ADDRESS = payable(vm.addr(BOB_PK));
        ALICE_ADDRESS = vm.addr(0xA11CE);
        IDENTITY_COMMITMENT = keccak256("bob_identity_salt");

        tokenA = new MockERC20();
        
        // Deploy the REAL HonkVerifier
        verifier = new HonkVerifier();
        
        // Deploy ProofHeir with real verifier
        proofHeir = new ProofHeir(address(verifier), TRUSTED_SERVER_DOMAIN, address(this));

        tokenA.mint(BOB_ADDRESS, 1000);
    }

    /**
     * @notice Test that the HonkVerifier contract deploys correctly.
     */
    function testVerifierDeployment() public view {
        // HonkVerifier should be deployed
        assertTrue(address(verifier) != address(0), "Verifier not deployed");
        
        // Verify the IVerifier interface is implemented
        // (this would fail at compile time if not, but explicit check is good)
        bytes4 selector = bytes4(keccak256("verify(bytes,bytes32[])"));
        console.log("Verifier contract deployed at:", address(verifier));
    }

    /**
     * @notice Test that ProofHeir correctly stores the server hash.
     */
    function testProofHeirInitialization() public view {
        assertEq(proofHeir.trustedServerHash(), SERVER_HASH, "Server hash mismatch");
        assertEq(address(proofHeir.verifier()), address(verifier), "Verifier mismatch");
    }

    /**
     * @notice Test that invalid proofs are rejected.
     * @dev This should always pass since random bytes are not valid proofs.
     */
    function testInvalidProofRejected() public {
        address[] memory tokens = new address[](1);
        tokens[0] = address(tokenA);

        bytes memory invalidProof = hex"deadbeef";
        bytes32[] memory publicInputs = new bytes32[](4);
        publicInputs[0] = bytes32(uint256(uint160(ALICE_ADDRESS)));
        publicInputs[1] = IDENTITY_COMMITMENT;
        publicInputs[2] = SERVER_HASH;
        publicInputs[3] = bytes32(uint256(0x999));

        vm.signAndAttachDelegation(address(proofHeir), BOB_PK);
        
        vm.prank(BOB_ADDRESS);
        ProofHeir(BOB_ADDRESS).registerIdentity(IDENTITY_COMMITMENT);

        vm.startPrank(ALICE_ADDRESS);
        // Should revert because the proof is invalid
        vm.expectRevert(); // Generic revert - proof verification will fail
        ProofHeir(BOB_ADDRESS).proveDeathAndRegisterHeir(invalidProof, publicInputs);
        vm.stopPrank();
    }

    /**
     * @notice Test with a real valid ZK proof generated from the circuit.
     * @dev Proof generated via Docker with aligned nargo 1.0.0-beta.15 + bb 3.0.0-nightly.20251104.
     *      Public inputs match Prover.toml: recipient=0xab*20, server_hash, id_commitment, status_commitment.
     */
    function testValidProofVerification() public {
        // Load proof from fixtures directory
        bytes memory proof = vm.readFileBinary("test/fixtures/proof");
        
        // Build public inputs array matching the circuit's serialization.
        // The circuit serializes each [u8; N] as N field elements (each byte expanded to 32 bytes).
        // Total public inputs: 20 (recipient) + 32 (server_hash) + 32 (id_commitment) + 32 (status_commitment) = 116 fields
        bytes32[] memory publicInputs = new bytes32[](116);
        
        // Recipient (0xab * 20)
        for (uint i = 0; i < 20; i++) {
            publicInputs[i] = bytes32(uint256(0xab));
        }
        
        // Server Hash (bytes from Prover.toml)
        bytes memory serverHashBytes = hex"5ddeed97a3950919f49ab7e413eeb1272467a129b6a75b59ac81da0516bdfb92";
        for (uint i = 0; i < 32; i++) {
            publicInputs[20 + i] = bytes32(uint256(uint8(serverHashBytes[i])));
        }
        
        // ID Commitment (bytes from Prover.toml)
        bytes memory idCommitmentBytes = hex"a1c76f304fba049ca3c1edd85d7aefa1f3e800176153084a58e1494e088638f5";
        for (uint i = 0; i < 32; i++) {
            publicInputs[52 + i] = bytes32(uint256(uint8(idCommitmentBytes[i])));
        }
        
        // Status Commitment (bytes from Prover.toml)
        bytes memory statusCommitmentBytes = hex"7215deae275bac9a08b1c48a13ebf9c24330732de02f94709fefcd8b0a9b75d8";
        for (uint i = 0; i < 32; i++) {
            publicInputs[84 + i] = bytes32(uint256(uint8(statusCommitmentBytes[i])));
        }
        
        console.log("Proof length:", proof.length);
        console.log("Public inputs count:", publicInputs.length);
        
        // Verify the proof using the real HonkVerifier
        bool result = verifier.verify(proof, publicInputs);
        assertTrue(result, "Valid proof should verify");
    }

    /**
     * @notice Full end-to-end test: EIP-7702 delegation + ZK proof verification + asset claim.
     * @dev Uses real proof from Noir circuit to verify death certificate and transfer assets.
     */
    function testFullClaimWithRealProof() public {
        // Load proof from fixtures
        bytes memory proof = vm.readFileBinary("test/fixtures/proof");
        
        // Build public inputs matching Prover.toml (116 fields)
        bytes32[] memory publicInputs = _buildPublicInputs();
        
        // Identity commitment matching Prover.toml
        bytes32 idCommitment = 0xa1c76f304fba049ca3c1edd85d7aefa1f3e800176153084a58e1494e088638f5;
        
        // The recipient in the proof is 0xab repeated 20 times
        address proofRecipient = address(0xABaBaBaBABabABabAbAbABAbABabababaBaBABaB);
        
        // Setup tokens to claim
        address[] memory tokens = new address[](1);
        tokens[0] = address(tokenA);
        
        // EIP-7702: Bob delegates his account to ProofHeir implementation
        vm.signAndAttachDelegation(address(proofHeir), BOB_PK);
        
        // Bob registers his identity commitment on his delegated account
        vm.prank(BOB_ADDRESS);
        ProofHeir(BOB_ADDRESS).registerIdentity(idCommitment);
        
        // Verify registration worked
        assertEq(ProofHeir(BOB_ADDRESS).getIdentityCommitment(), idCommitment, "Identity not registered");
        
        // Check initial balances
        assertEq(tokenA.balanceOf(BOB_ADDRESS), 1000, "Bob should have 1000 tokens");
        assertEq(tokenA.balanceOf(proofRecipient), 0, "Recipient should have 0 tokens initially");
        
        // Step 1: Register heir with valid ZK proof (anyone can call this)
        vm.prank(ALICE_ADDRESS);
        ProofHeir(BOB_ADDRESS).proveDeathAndRegisterHeir(proof, publicInputs);
        
        // Step 2: Claim and transfer tokens to the registered heir
        vm.prank(ALICE_ADDRESS);
        ProofHeir(BOB_ADDRESS).claimInheritance(tokens);
        
        // Verify tokens transferred to the proof recipient
        assertEq(tokenA.balanceOf(BOB_ADDRESS), 0, "Bob should have 0 tokens after claim");
        assertEq(tokenA.balanceOf(proofRecipient), 1000, "Recipient should have 1000 tokens");
        
        console.log("Full end-to-end claim with real ZK proof succeeded!");
    }

    /**
     * @dev Helper to build public inputs array matching circuit serialization.
     */
    function _buildPublicInputs() internal pure returns (bytes32[] memory) {
        bytes32[] memory publicInputs = new bytes32[](116);
        
        // Recipient (0xab * 20)
        for (uint i = 0; i < 20; i++) {
            publicInputs[i] = bytes32(uint256(0xab));
        }
        
        // Server Hash
        bytes memory serverHashBytes = hex"5ddeed97a3950919f49ab7e413eeb1272467a129b6a75b59ac81da0516bdfb92";
        for (uint i = 0; i < 32; i++) {
            publicInputs[20 + i] = bytes32(uint256(uint8(serverHashBytes[i])));
        }
        
        // ID Commitment
        bytes memory idCommitmentBytes = hex"a1c76f304fba049ca3c1edd85d7aefa1f3e800176153084a58e1494e088638f5";
        for (uint i = 0; i < 32; i++) {
            publicInputs[52 + i] = bytes32(uint256(uint8(idCommitmentBytes[i])));
        }
        
        // Status Commitment
        bytes memory statusCommitmentBytes = hex"7215deae275bac9a08b1c48a13ebf9c24330732de02f94709fefcd8b0a9b75d8";
        for (uint i = 0; i < 32; i++) {
            publicInputs[84 + i] = bytes32(uint256(uint8(statusCommitmentBytes[i])));
        }
        
        return publicInputs;
    }
}
