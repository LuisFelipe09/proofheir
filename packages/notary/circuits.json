{"noir_version":"1.0.0-beta.8+ba05d729b9753aa5ce2b076c1dd4795edb173f68","hash":"9207533224017163493","abi":{"parameters":[{"name":"recipient","type":{"kind":"array","length":20,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"server_hash","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"id_commitment","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"status_commitment","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"nuip","type":{"kind":"string","length":15},"visibility":"private"},{"name":"salt","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"server_domain","type":{"kind":"string","length":40},"visibility":"private"},{"name":"status","type":{"kind":"string","length":22},"visibility":"private"},{"name":"status_blinder","type":{"kind":"array","length":16,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"}],"return_type":null,"error_types":{"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"6668324276689745315":{"error_kind":"string","string":"Field failed to decompose into specified 4 limbs"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"14514982005979867414":{"error_kind":"string","string":"attempt to bit-shift with overflow"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"7Z3drtzGsYXfRdf7gl1dXdWdVzECQ3aUQIBgG4od4MDIux/2T621JZgcirON5CI36qXZw/V1N1nFZg2H8/u7v3344bd/fP/xp7///M93f/nu93c/fP746dPHf3z/6ecf3//68eef9ld/f7f1f2z/N728szQbmU2ejc6mzMZm47Ops2mj8eni08Wni08Xny4+XXy6+HTx6eLTpU6XOl3qdKnTpU6XOl3qdKnTpU6XOl3adGnTpU2XNl3adGnTpU2XNl3adGnTJW3batNqZbV5tbraslpbra+2rnb5peWXll9afmn5pd1PeltWa6vd/eTfu+h7qw8xzyHmOcQ8h5jnEPMcYp5DzHOIeQ4xzyHmOcS8hpjXEPMaYl5DzGuIeQ0xryHmNURdQyprSGUNqawhlTUk6+3O872VbbVptbLa/e91b/O22rRaWe3u13qrqy2rtdX6avuUb7vQvk/6pGp/pc9i6bPe+14kRA7Rd2QfTikhLISHqEuMOOljG7HRBzeiYwgL4SFqiLa6MeJkiBRCQuQQGqKEsBC+xIiUPnUjVoaQEDlE9+nTN+Kiz8+IjCFSCAmRQ2iIEqIfiH1W+0E0RZ1C+oEjqYvdR3IXu49oF2t+ZCshLISHqCF6D20/yGWkpM4pM8WMts22T95o02pltZ1pM9GMtqzWVtv9fCab3vYZkjpTirSZU0Zrq/XV1tW22fbpG20Pl23F3bYCb1uRt7JLXuklr/ySdUWfrvDTiD+NANSIQI0Q1IhBjSAsEYW+wnCIHne5rsCbQkOUEBai09uKxilSCAmRQ2iIEsJC9CTQjwapIdoSPY6nSCF2Q00rhKfoW/VDWft7ehyqhMghNEQJYSE8RA3Rliidrivm1VfMT5FDaIgSwkJ4iBqiO/ep6+fKKbpzn4R+vix9gP2MOcXuXNLKC1NYiN25yMoLJa+8MEQ/tIuuvFDKygtT5BDd2VZeKL7yQqkrL5Ten36IT7E727YyhaWVKabYnU1WpphCQ5QQFsJD1BDdOa9sMkUK0Z11ZRMrK5uYrWwyhYXozr6yifVR9Liw1tNBP09EfplCQuzOnlZ+cVn5xfPKL64rv0yxO3tZ+cV7oulnLPcuUggJkUNoiBLCQnTD2kVbYpzShkghumEfRQ+iKTRECWEhPEQN0ZboQeRtz4m558T/LZtOlk1pJbq08txol19afmn5yfKT5SfLT5afLD9ZfrL8ZPnJ8pPl13eTrFQ3Wlltnss27XvvP7lQy2tS85pUffnjhVpZk1jWJNrLHyzU8mp1tn+0UButrvZkoTbaNlvdYuHma+FWYqH05TJtiBLieJnWU/Zcr20hcizcHizTbKXjKZ5bpnksPz0WgAfLNF/JdwpbC7dvXqZN4SFqrNdarNe2EDkWbhoLtxILt0fLtJVGp0hr4VZGkvrfld5/a8qSlbLk65S17zsbKerPyzh5zUlec5LXnOQ1J3nNSV5zktec6JqDsuagrDkoaw7KmgNbY4xLSV9jjAzlK+PUlXHqyjijXRmsLz5HJlqXmrouNXVlMF0ZbCSoLdJRiuQjkWrGqi6uNS2uNUfyGVkorjUtrjUtkphFEhvJJ1Z+MwvFtabHtaZHEvNIYn+QaiKF1vQ6+cTKL8XKL8XKL8XKL8U6b6SjFteaLa41WySxEWt1pZqZc9a15kg1U6QQEiKH0BAl8pKFWNeaI9WMTNWPnJGp+qEzMlXKkYXiWjPFtWaKJJYiiY2g6pnK4xIz/a+I9V+V2mSFtaywlpXa5N/7XovC5fe/fv7woe/BV5XMvb75y/vPH3769d1ffvrt06eXd/96/+m38aZ//vL+p9H++v7z/tf9ePrw09/2djf8+8dPH7r69wu33o43rS2tjZtkbC5ydXvvV5Jje6/bje2L1LoMdtngUPyyg24aDir1joP1C67pYE1vORR/0sG3Eg4ut+ah9Qvk6dBqetqh3HPA3mzNbzjY1rPacLBN7vTBtFdLpoOWWw6bbeiD3ZlJ2/N8OOzX1HcckmMe9rPZHYdcC+bhVWzfHMVNh4I+iG+3HBr2Zt7slkNtdLh1TGbFKLLas/tiOzwmRY4t9mvPEkflru9Npm71uUOi1RapsrV0pw979VKjE7v2dM+jbvRo9zx4ZO0X48lueeTMseRbyWbfrhV46K0DtG/X6CH39kt+Nacqh3Oazw7SvVKCSd2rJIeHWH/XoYnuy+4w2QdTb5og7LtJuzkcKRzO8akg21ngZh5oeV+s3DN5Pvr3PWw80rLfPNLUeJTYvagpHEspnu95OPtRar3l4cKocb0Xve5Oj1sL2O7BsdRNjjz6WehkHb1hHd24W1L90uLkGNtXwZHbzbUeWZyOpGbORtV7s/GFR7GbHq9m1O4dYdUZLbX68x63Lgy6h8Kjbenp+bjr0RLPl03K8x5ZbnrIK4/6/Hzc9GivslgzeQOP9vxYbp4ZamI/ar4VL7Zhcbnre2uQrzz8pofTI+s9D57lbCv1eQ8rNz0KPVyen4+7HlXp0expj71Qd9Mjv/JoT8/HXY8kiR434+ULD92eH4vezOv+6vjY7p2jLPEcZeneuWGvGL3yuDMWxxqobq/m88tiaN1Ol9mYi/w6VL6ySMcWojVOT1JeX8196XBy1bF/shATsX+2YE87tCMHPZkISZgIydutPmzsQz7sw+nOcF4Gvo7Tr3aG/3nV7YrlSpXDA+ps+wq++tH27cFqB8H5es31lcXZAcnKsni6Z2G4lt7d5NZArHAg9XAu28kxWRXRXQ5XBmcG+6c0OJvKicXZdXhVnsVqOS7Un5tYwWms+nEZrZdBjnMdrta8Hq9yLluUdMeiJovdWvePc+9ZYA1818JbdSb+wx27LzrOso0priv2Qkm9t2crT8j15OI1bSfX8vt2sXKsdnyI7R9qnhRqjanHj0+m3+Dh9zxeF4yPFxfXPY6j5YEHjrJW7V7sN+XV657PjyckndYULeG0tmfFcuyS36DQmtJZQlTFp227znddctvoclxdeDSia7XWlPwNoviRC+clm/hNF9/yq9XkdrcvXJ9nq3dH5Kz97usqueuSG13KdjMCXHC87Blf7gVjbspgPDmHnpoYP/PYU9zNnjTm/HZSxHlggsXuvnLW40iUerrIcozHLB/HUC98H6ZKQSDuq2a/5/H61HGS9i97pPQGHjfHcvEUdu5x6fRzvR8np8HzI8R4lW1ux6PJZ3lgL8PAZTup8z9y4XljaycLndxOr1Q3rur3DHnootvpmfDVxaa2cndEm3Be5DjLqrzFOezBiC6e289drp7bz/eRsL4sIrePOudR127v6Yx7UnZ9fP/BIxd+dqj5uHp3PqK00WVfvspNl2R0SfW2C+flGRdWAvdl3M0stRcZsHLaTx/2Fi4nK+0HLrhDMe2noTdxOYmAc5fE87vL8XrlW1zy3REJF2B+cv/M2bJnX+rgvLjreny4WDrrSuHHrH5SOn7gwkLZrlN+C5eTU8AjF06un+wie/6egGTP3xTwaDSvDpV6vIQ6LSD6lnjQ1qMC4kiFx4db5tH2+lPfb7G4UlpPnp6trT/oxZXi+vl05le7JB1Op+ufV11vuM22HX/WcjaGLSeutrbjMfjpdeSrK8Djw8rr03Xl5O0NCssPXC5WltPZR1hfFHVPLlYuexxXdU89rpZ1Tz/IuryYPh/NpRr1+WiuFeyvexxX7B8cI1dr1LU9X6Nu2/NFglMPxd3ETcsb9ONk9dCevzH6usfd+bhYaDg9Qq7W1h64XCyuPXC5WF175HKtvLb/8Q3Ka7Klp8tr5x7XIue6R0pv4HFzLNeO+gcel4766/04PuYfHCEXy2uytTcoCzxwuVgWeORyrSzwyOVaWeB8dq+WBb7F5bgs8MjlWlngW1xEb7pcLAt8i0u+O6KLZYHTfH25LiDyFnWBBy4X6wLf4nJcF3jocqkuMM4xT9YFRJ6vCzwazbW6wIMruPbHV+TbVz15ujDwwOJKYUDy04WBB724Uhg4nc99O9wvdnJVLflPrAz08j5PgOVObSDhu8xJtpNRnM2E4A5uEfdjj5PagDTc5Svt9VXfN3ngOlhau+vh7EfVe/ORcT+D5HxYsZHTD7eu1UpE8xvUSh64XKyVyNn3ri7WOU49LtY5RN/ixpcHo7lU5zgfzbU6x3WP4zrHg/17sc4hRZ6uc0jJz19pXffwex4Xr7Que5zFzNmeuXojnZTTquvFG+mknF6ZXLyRTuwtPlR+5HLtQ+VHI7p2I53YW9wO+8jl2o10D1wu3kj3yOXaLXCPXK7dAvfg2L14C9yDOLpYp3vgcrFO98DlYp3ukcvFOp3nt6jTnX26dbVOd+pxsU536nGtwn29H+nmfFw8e5x7XKvTXe7HyTF/foRcrdOdfcUpbVqR3TY9ft7RucvlOt0Dl4t1ugcuF+t0p7N7uU73DS4n5/cHLhfrdN/gclKnO3e5Wqf7Bpd8d0QX63Sn+fp6ne70e1mX63TnLlfrdN/gclKne+RyrU539rWmq3W61p6v0z0YzbU63YPqQWH1oOaj6kHe5Nk63QOLK3W6vD395dgHvbhSp3swn/xSpoofz+ef+P3YfsM1ZuKrPvx1/9/7Hz9+/vK3ecYT5nsJaDxhfooUQkLkEBqihLAQHqI/AdfWE+bHKzmccziP53j39+RwzuGcw7k/y3u+J5zHs3WHCOfxdN3+Hg1njT5rOPcn7M73hLNGnzWcNfqs4VyizyWcS/S5hHOJPpdwLtHnEs4l+lzC2aLPFs4WfbZwtuizhbNFny2cLfps4ezRZw9njz57OHv02cPZo88ezh599nCu0ecazjX6XMO5Rp9rONfocw3nGn2u4dyizy2cW/S5hXOLPrdwbtHnFs4t+tyWc95Wn/OW4hUJkUNovKc71y66c+vCQ9QQbYn+cNopUggJkUNoiBIinFM4p3BO4SzhLOEs4SzhLOEs4SzhLOHcY7B5F22JHoNTpBASIofQEP2puv1TxdyDcCmHqlAt1HywvnaVoPoze3vSzT0Wl1JsUfCaQTm2rVAt/joe1T8VGONXlqYCYzwxeyqMo4AxHqM9FRjjKf5DGRjj4dpTgTEerz0VGIZxGObKwBgPfp4KDMdcORiOuXIwxqOgpwLDMQ7H/nAwHHNVwaiYq4pxVDAq9sd4VnQ/N+XxuOipHGoweoCM50b3b4/k8ejoqRKUQGUohRo/l9UDbzxMeiqHqlCDsdN0PFe6l2Z0PFl6qvF0ce0qQ3VG/80lHU+YnsqgHKpCtVDjWdNTJajxRHXpKkMp1PhliNxVZ/TnPel48vRUFaqFGs+f7r9HpOPh+lMJVIbqjL7C1/GQ/anGk9v7KMeD9qeqUC1UHoxOywlKoDLUYPRRjjifyoI24nyqweh7YcT5UCPOp0pQYCgYI86nKlAWtBHnU9WgjTgfasR5v4zREef90wAdcT5VhlKoAmVQDlWhWqgR5732qyPObbwmUBlKoQqUQTlUhWqh5o97DAWGg+FgOBjzsft9XuZz94dyqArVQo04nypBCVSGUigwKhgVjApGBaOB0cBoYDQwGhgNjAZGA6OB0YJRtg0qQQlUhlKoAmVQDlWhwEhgJDASGAmMBEYCI4GRwEhgJDAEDAFDwBhx3p9tXkacT1WgDMqhKlQLNeJ8qgQlUGBkMEac9+pDyWBkMDIYGYwR52MLBUPBUDAUDAVDwVAwFAwFo4BRwChgFDAKGAWMAkYBo4BRwDAwDAwDw8AwMAwMA8PAMDAMDAfDwXAwHAwHw8FwMBwMB8PBqGBUMCoYFYwKRgWjglHBqGBUMBoYDYwGRgOjgdHAaGA0MBoYLRi2BcO2hNcEKkMpVMEWhtccqkKBkcBIYCQwEhgJjARGAiOBkcBIYAgYAoaAgTg3xLkJGIhzQ5wb4twQ55bBQJwb4twQ54Y4N8S5Ic4NcW6Ic0OcG+LcEOeGODfEuSHODXFuiHNDnBvi3BDnhjg3xLkhzg1xbohzQ5wb4twQ54Y4N8S5Ic4NcW6Ic0OcG+LcEOeGODfEuSHODXFuiHNDnBvi3BDnhjg3xLkhzg1xbohzQ5wb4txmnJeuBsO6ylAKVaAMyqEqVAs143yoBAVGA6OB0cBoYDQwGhgtGL5tUAlKoDKUQhUog3KoCgVGAiOBkcBIYIw475VbH3E+lUE5VIVqoUacT5WgBCpDgSFgjDjv1QUfcT7VYJSuWqgR5+OvI86nEvw1Qyn+WqAGo3YFxojzqcAYcT4VGCPOpwJjxPlUYCjGMeJ80BSMEedDFTBGnE8FxojzqcAYcT4VGAXjGHE+aAUMw1wZGIa5MjAMc2VgjDifCgzDOEacD5qD4ZgrB8MxVw6GY64cjBHnU4HhGMeI80GrYFTMVQWjYq4qGBVzVcGoOK4qGA3jGHE+aA2MhrlqYDTMVQOjYa4aGC2Oq7oFo24JShatbhmvKVTBtgbl+GuFAiNtUGAkgcpBS2CkAgVGcigwUsxVFTAkQYEhGMeM804TMBDnVcBAnFcBA3FeMxiI85rBQJzXGeedNuK8f+hTR5xPVaFaqBHnUyWo8XtorasMpVAFyqAcqkK1UCPOp0pQYBQwChhl/Oxa70sxKIcaPx/Z56CM34/s47UNKkH13+zqdaRq41clpSuFKlAG5VAVqoUaP/M9VYISqM7o9aY6fu5bxmsFysY9yF05VIVqoXqcL5WgBCpDKVSBAqOCUcGoYDQwGhgNjAZGA6OB0cBoYDQwWjDatkElKIHKUApVoAzKoSoUGAmMBEYCI4GRwEhgJDASGAmMBIaAIWAIGALG+D24XutrPc6XMiiHqlAt1PjZy6kSlEBlKDAyGHkw+u9jZjAyGBkMBUNTbKFgKBgKhoKhYCgYCoaCUcAoYBQwChgFjAJGAaOAUcAoYBgYBoaBYWAYGAaGgWFgGBgGhoPhYDgYDoaD4WA4GA6Gg+FgVDAqGBWMCkYFo4JRwahgVDAqGA2MBkYDo4HRwGhgNDAaGA2MFoz9o4CNMii7FL6aKZWyUBo3c75aKUlLpCXSEmmJtERaIi2RlkhLpCXShDQhTUgT0oQ0IU1IE9KENCEtk5ZJy6Rl0jJpmbRMWiYtk5ZJU9KUNCVNSVPSlDQlTUlT0pS0QlohrZBWSCukFdIKaYW0QlohzUgz0ow0I81IM9KMNCPNSDPSnDQnzUlz0pw0J81Jc9KcNCetklZJm6mjDDloNqRSFkqjdMpK2SBnCpkyUQolaY20RlojrZHWSGugpW2jTJRCmSmVslAapVNWStISaYm0RFoiLZE2comOn4AeuWRJp6yUDXLkkiUTpVBmSqUkTUgT0oS0kUu0/9jx/CXtJQetDimUmW9QysI3GKXzDZWy08r8bV3SRi5ZkrSRS5YkbeSSJUkbuWRJ0pRjG7lkggtpI5csSdrIJUuSNnLJkqSNXLIkacaxjVwywUaacSaNNONMGmnGmTTSRi6Z0klzjm3kkgl20pwz6aQ5Z9JJc86kkzZyyZKkVY5t5JIJrqRVzmQlrXImK2mVM9lIazwmG2mNYxu5ZIIbaY0z2UhrnMkG2viZ75CgjZ/6Dpn5BqUsAZ4/+b1edcpKB8zk/DHw+YaUKElLmZK0VCgN4ERaqpSkyUZJmgglaaKUpAnHNnLJBAtpzCWSSWMukUwac4lk0phLJJPGXDLuzlvgTBpziShpzCWipDGXiJLGXCJKGnPJuGdvgQtpzCVSSGMukUIac4kU0phLxl18gRi0nqDHnXwhE+WI7jLkiDcfUikLpVF2mg3EyCVLNsiRS5bsNBu0kUuW7DQboxi5ZMlO658tpHGnX0inrJQNcuSSJROlUGZKpSStklZJq6RV0kYuqWNsI5cs2Wl1zOTIJUsqZaE0SqeslC3kuDMwZKIUykzZaf3L72ncIyhtvmr9Rt5tSKeslA2y55KQiVIoM6VSFkrSEmmJtESakCakCWlCmpAmpAlpQpqQJqRl0jJpmbRMWiYtk5ZJy6Rl0jJpSpqSpqQpaUqakqakKWlKmpJWSCukFdIKaWXQxqFRCqVROmWlbJC2USZKocyUpBlpNmg2JGlGmpHmpHnCZk6ak+akOWlOmpPmpDlplbRKWiWtklZJq6RV0ipplbRKWiOtkdZIa6Q10hppjbRGWiOtgTZuUAwJ2rhFMV7NlEpZKI2bOV+tlKQl0hJpibREWiItkZZIS6Ql0hJpQpqQJqQJaUKakCakCWlCmpCWScukZdIyaZm0TFomLZOWScukKWlKmpKmpClpSpqSpqQpaUpaIa2QVkgrpDGXKHOJFtKYS5S5RJlLlLlEjTTmEmUuUeYSZS5R5hJlLlHmEmUuUeYSZS5R5hJlLlHmEmUuUeYSZS5R5hJlLlHmEmUuUeYSZS5R5hJlLlHmEmUuUeYSZS5R5hJlLlHmEmUuUeYSZS5R5hJlLlHmEmUuKcwlhbmkMJcU5pLCXFKYSwpzSWEuKcwlhbmkMJcU5pIyc0kdctDakEpZKI3SKStlg5y5ZMpEKZSkCWlCmpAmpAlpQlomLZOWScukZdIyaZm0TFomLZOmpClpSpqSNnNJ/4LZv95//vj+h08f/vnuL7/3L2r99tOP8a2s/b+//t8v8ZcfPn/89OnjP77/5fPPP37422+fP/RvcPW/vdv6P7v3d+ovxf+6+++vfLdfN7/sV0X9+15pveu7/arvZb+A2d/S3+75peZ4e/+4c79G7f9N/b+SXvYLzr61YOv90mdfqa+ty/ZiG7beC5b7pR+2zu1lv9DrW+fonOUXB21f9Lzsp7T+BmXn9h6UHJ0rL7Wwc7p3rrFzO01K37rAPr14on1+2VcD/Q1G+71Po8f97VVemsB+DNbY+32WsvStPez3izpT2Ivt9vvw+tfp/h8=","file_map":{"5":{"source":"use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { $crate::cmp::Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::cmp::Ord };\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> $crate::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == $crate::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = $crate::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, name, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0_u64, 1), 0);\n        assert_eq(min(0_u64, 0), 0);\n        assert_eq(min(1_u64, 1), 1);\n        assert_eq(min(255_u8, 0), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0_u64, 1), 1);\n        assert_eq(max(0_u64, 0), 0);\n        assert_eq(max(1_u64, 1), 1);\n        assert_eq(max(255_u8, 0), 255);\n    }\n}\n","path":"std/cmp.nr"},"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This slice will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    unconstrained fn not_enough_limbs_brillig() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    fn not_enough_limbs() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"22":{"source":"pub mod hash;\npub mod aes128;\npub mod array;\npub mod slice;\npub mod ecdsa_secp256k1;\npub mod ecdsa_secp256r1;\npub mod embedded_curve_ops;\npub mod field;\npub mod collections;\npub mod compat;\npub mod convert;\npub mod option;\npub mod string;\npub mod test;\npub mod cmp;\npub mod ops;\npub mod default;\npub mod prelude;\npub mod runtime;\npub mod meta;\npub mod append;\npub mod mem;\npub mod panic;\npub mod hint;\n\nuse convert::AsPrimitive;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained fn print_unconstrained<T>(with_newline: bool, input: T) {\n    print_oracle(with_newline, input);\n}\n\npub fn println<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(true, input);\n    }\n}\n\npub fn print<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(false, input);\n    }\n}\n\npub fn verify_proof<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n) {\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, 0);\n}\n\npub fn verify_proof_with_type<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {\n    if !crate::runtime::is_unconstrained() {\n        crate::assert_constant(proof_type);\n    }\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, proof_type);\n}\n\n#[foreign(recursive_aggregation)]\nfn verify_proof_internal<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time.\n// The message can be a string, a format string, or any value, as long as it is known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<T>(predicate: bool, message: T) {}\n\n#[deprecated(\"wrapping operations should be done with the Wrapping traits. E.g: x.wrapping_add(y)\")]\npub fn wrapping_add<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n#[deprecated(\"wrapping operations should be done with the Wrapping traits. E.g: x.wrapping_sub(y)\")]\npub fn wrapping_sub<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    AsPrimitive::as_(x.as_() + 340282366920938463463374607431768211456 - y.as_())\n}\n#[deprecated(\"wrapping operations should be done with the Wrapping traits. E.g: x.wrapping_mul(y)\")]\npub fn wrapping_mul<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n\nmod tests {\n    use super::ops::arith::WrappingMul;\n\n    #[test(should_fail_with = \"custom message\")]\n    fn test_static_assert_custom_message() {\n        super::static_assert(1 == 2, \"custom message\");\n    }\n\n    #[test]\n    fn test_wrapping_mul() {\n        let zero: u128 = 0;\n        let one: u128 = 1;\n        let two_pow_64: u128 = 0x10000000000000000;\n        let u128_max: u128 = 0xffffffffffffffffffffffffffffffff;\n\n        // 1*0==0\n        assert_eq(zero, zero.wrapping_mul(one));\n\n        // 0*1==0\n        assert_eq(zero, one.wrapping_mul(zero));\n\n        // 1*1==1\n        assert_eq(one, one.wrapping_mul(one));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(zero, zero.wrapping_mul(two_pow_64));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(zero, two_pow_64.wrapping_mul(zero));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(two_pow_64, two_pow_64.wrapping_mul(one));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(two_pow_64, one.wrapping_mul(two_pow_64));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(zero, two_pow_64.wrapping_mul(two_pow_64));\n        // -1 * -1 == 1\n        assert_eq(one, u128_max.wrapping_mul(u128_max));\n    }\n}\n","path":"std/lib.nr"},"50":{"source":"use dep::sha256;\n\nfn main(\n    // Public Inputs\n    recipient: pub [u8; 20],      // To prevent front-running\n    server_hash: pub [u8; 32],    // Expected Server Identity Hash (SHA256)\n    id_commitment: pub [u8; 32],  // Expected Identity Hash (SHA256(nuip + salt))\n    status_commitment: pub [u8; 32], // TLS Commitment for the Status field (SHA256)\n\n    // Private Inputs (Authenticated Data from TLS)\n    nuip: str<15>,               // e.g. \"1234567890\"\n    salt: [u8; 32],              // Salt derived from email\n    server_domain: str<40>,      // e.g. \"civil-registry-mock.onrender.com\"\n    status: str<22>,             // \"No Vigente (Fallecido)\"\n    status_blinder: [u8; 16]     // Blinder for the status commitment\n) {\n    // 1. Check Status Content\n    let is_dead = check_status(status);\n    assert(is_dead);\n\n    // 2. Check Status Commitment\n    let status_valid = check_status_commitment(status, status_blinder, status_commitment);\n    assert(status_valid);\n\n    // 3. Check Server Identity\n    let server_valid = check_server_identity(server_domain, server_hash);\n    assert(server_valid);\n\n    // 4. Check Identity\n    let identity_valid = check_identity(nuip, salt, id_commitment);\n    assert(identity_valid);\n}\n\nfn check_status(status: str<22>) -> bool {\n    let expected_status = \"No Vigente (Fallecido)\";\n    let is_equal = status == expected_status;\n    println(f\"Is Dead? {is_equal}\");\n    is_equal\n}\n\nfn check_status_commitment(status: str<22>, blinder: [u8; 16], commitment: [u8; 32]) -> bool {\n    // 22 bytes status + 16 bytes blinder = 38 bytes\n    let input = make_status_input(status, blinder);\n    let computed_hash = sha256::sha256_var(input, 38);\n    let is_valid = computed_hash == commitment;\n    println(f\"Status Commitment Valid? {is_valid}\");\n    is_valid\n}\n\nfn check_server_identity(server_domain: str<40>, expected_hash: [u8; 32]) -> bool {\n    // 40 bytes domain\n    let computed_hash = sha256::sha256_var(server_domain.as_bytes(), 40);\n    let is_valid = computed_hash == expected_hash;\n    println(f\"Server Identity Valid? {is_valid}\");\n    is_valid\n}\n\nfn check_identity(nuip: str<15>, salt: [u8; 32], expected_hash: [u8; 32]) -> bool {\n    // 15 bytes nuip + 32 bytes salt = 47 bytes\n    let input = make_identity_input(nuip, salt);\n    let computed_hash = sha256::sha256_var(input, 47);\n    let is_valid = computed_hash == expected_hash;\n    println(f\"Identity Valid? {is_valid}\");\n    is_valid\n}\n\nfn make_status_input(status: str<22>, blinder: [u8; 16]) -> [u8; 38] {\n    let mut input: [u8; 38] = [0; 38];\n    let status_bytes = status.as_bytes();\n    for i in 0..22 {\n        input[i] = status_bytes[i];\n    }\n    for i in 0..16 {\n        input[22 + i] = blinder[i];\n    }\n    input\n}\n\nfn make_identity_input(nuip: str<15>, salt: [u8; 32]) -> [u8; 47] {\n    let mut input: [u8; 47] = [0; 47];\n    let nuip_bytes = nuip.as_bytes();\n    for i in 0..15 {\n        input[i] = nuip_bytes[i];\n    }\n    for i in 0..32 {\n        input[15 + i] = salt[i];\n    }\n    input\n}\n\n#[test]\nfn test_main() {\n    let recipient = [0xabu8; 20];\n    \n    let nuip: str<15> = \"123456789012345\";\n    let salt = [0x11u8; 32];\n    let server_domain: str<40> = \"civil-registry-mock.onrender.com        \"; // padded to 40\n    let status: str<22> = \"No Vigente (Fallecido)\";\n    let status_blinder = [0x22u8; 16];\n\n    // Compute expected commitments\n    let server_hash = sha256::sha256_var(server_domain.as_bytes(), 40);\n    \n    let id_input = make_identity_input(nuip, salt);\n    let id_commitment = sha256::sha256_var(id_input, 47);\n\n    let status_input = make_status_input(status, status_blinder);\n    let status_commitment = sha256::sha256_var(status_input, 38);\n\n    main(\n        recipient,\n        server_hash,\n        id_commitment,\n        status_commitment,\n        nuip,\n        salt,\n        server_domain,\n        status,\n        status_blinder\n    );\n}\n\n#[test(should_fail)]\nfn test_main_wrong_status() {\n    let recipient = [0xabu8; 20];\n    let nuip: str<15> = \"123456789012345\";\n    let salt = [0x11u8; 32];\n    let server_domain: str<40> = \"civil-registry-mock.onrender.com        \"; // padded to 40\n    let status: str<22> = \"Vigente (Vivo)        \"; \n    let status_blinder = [0x22u8; 16];\n\n    let server_hash = sha256::sha256_var(server_domain.as_bytes(), 40);\n    \n    let id_input = make_identity_input(nuip, salt);\n    let id_commitment = sha256::sha256_var(id_input, 47);\n\n    let status_input = make_status_input(status, status_blinder);\n    let status_commitment = sha256::sha256_var(status_input, 38);\n\n    main(\n        recipient,\n        server_hash,\n        id_commitment,\n        status_commitment,\n        nuip,\n        salt,\n        server_domain,\n        status,\n        status_blinder\n    );\n}\n","path":"/Users/felipe/Documents/hackathons/mantle/proofheir/packages/circuits/src/main.nr"},"57":{"source":"use std::hash::sha256_compression;\nuse std::runtime::is_unconstrained;\n\nuse constants::{\n    BLOCK_BYTE_PTR, BLOCK_SIZE, HASH, INITIAL_STATE, INT_BLOCK, INT_BLOCK_SIZE, INT_SIZE,\n    INT_SIZE_PTR, MSG_BLOCK, MSG_SIZE_PTR, STATE, TWO_POW_16, TWO_POW_24, TWO_POW_32, TWO_POW_8,\n};\n\npub(crate) mod constants;\nmod tests;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    assert(message_size <= N);\n\n    if std::runtime::is_unconstrained() {\n        // Safety: SHA256 is running as an unconstrained function.\n        unsafe {\n            __sha256_var(msg, message_size)\n        }\n    } else {\n        let (mut h, mut msg_block, mut msg_byte_ptr) =\n            process_full_blocks(msg, message_size, INITIAL_STATE);\n\n        finalize_sha256_blocks(msg, message_size, N, h, msg_block, msg_byte_ptr)\n    }\n}\n\npub(crate) unconstrained fn __sha_var<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    initial_state: STATE,\n) -> HASH {\n    let num_full_blocks = message_size / BLOCK_SIZE;\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = initial_state;\n    // Pointer into msg_block on a 64 byte scale\n    for i in 0..num_full_blocks {\n        let (msg_block, _) = build_msg_block(msg, message_size, BLOCK_SIZE * i);\n        h = sha256_compression(msg_block, h);\n    }\n\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n\n    finalize_last_sha256_block(h, message_size, msg)\n}\n\n// Helper function to finalize the message block with padding and length\npub(crate) unconstrained fn finalize_last_sha256_block<let N: u32>(\n    mut h: STATE,\n    message_size: u32,\n    msg: [u8; N],\n) -> HASH {\n    let modulo = message_size % BLOCK_SIZE;\n    let (mut msg_block, mut msg_byte_ptr): (INT_BLOCK, u32) = if modulo != 0 {\n        let num_full_blocks = message_size / BLOCK_SIZE;\n        let msg_start = BLOCK_SIZE * num_full_blocks;\n        let (new_msg_block, new_msg_byte_ptr) = build_msg_block(msg, message_size, msg_start);\n        (new_msg_block, new_msg_byte_ptr)\n    } else {\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        ([0; INT_BLOCK_SIZE], 0)\n    };\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    let index = msg_byte_ptr / INT_SIZE;\n    msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n    // If we don't have room to write the size, compress the block and reset it.\n    let (h, mut msg_byte_ptr): (STATE, u32) = if msg_byte_ptr >= MSG_SIZE_PTR {\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        (sha256_compression(msg_block, h), 0)\n    } else {\n        (h, msg_byte_ptr + 1)\n    };\n    msg_block = attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size);\n\n    hash_final_block(msg_block, h)\n}\n\n// Variable size SHA-256 hash\nunconstrained fn __sha256_var<let N: u32>(msg: [u8; N], message_size: u32) -> HASH {\n    __sha_var(msg, message_size, INITIAL_STATE)\n}\n\npub(crate) fn process_full_blocks<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    mut h: STATE,\n) -> (STATE, MSG_BLOCK, u32) {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n    let mut msg_byte_ptr = 0;\n    let num_blocks = N / BLOCK_SIZE;\n    for i in 0..num_blocks {\n        let msg_start = BLOCK_SIZE * i;\n        let (new_msg_block, new_msg_byte_ptr) =\n        // Safety: separate verification function\n            unsafe { build_msg_block(msg, message_size, msg_start) };\n\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        // Verify the block we are compressing was appropriately constructed\n        let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n        if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n\n        // If the block is filled, compress it.\n        // An un-filled block is handled after this loop.\n        if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n            h = sha256_compression(msg_block, h);\n        }\n    }\n    (h, msg_block, msg_byte_ptr)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeros.\npub(crate) unconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if message_size < msg_start {\n        // This function is sometimes called with `msg_start` past the end of the message.\n        // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n        0\n    } else if message_size < msg_start + BLOCK_SIZE {\n        message_size - msg_start\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let int_input = (block_input + INT_SIZE - 1) / INT_SIZE;\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = lshift8(msg_item, 1) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr = 0;\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = lshift8(msg_item, 1);\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeros by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // Check all the way to the end of the block.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = lshift8(msg_item, 1);\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\n#[inline_always]\nfn set_item_zeros(item: u32, zeros: u8) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros as u8);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts as u8);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\n#[inline_always]\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts as u8)\n}\n\n// Construct a field out of 4 bytes.\n#[inline_always]\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = lshift8(item, 1) + b1 as u32;\n    item = lshift8(item, 1) + b2 as u32;\n    item = lshift8(item, 1) + b3 as u32;\n    item\n}\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\n#[inline_always]\nfn lshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        // Brillig wouldn't shift 0<<4 without overflow.\n        if shifts >= 4 {\n            0\n        } else {\n            item << (8 * shifts)\n        }\n    } else {\n        // We can do a for loop up to INT_SIZE or an if-else.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item * TWO_POW_8\n        } else if shifts == 2 {\n            item * TWO_POW_16\n        } else if shifts == 3 {\n            item * TWO_POW_24\n        } else {\n            // Doesn't make sense, but it's most likely called on 0 anyway.\n            0\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\n#[inline_always]\nfn rshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        item >> (8 * shifts)\n    } else {\n        // Division wouldn't work on `Field`.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item / TWO_POW_8\n        } else if shifts == 2 {\n            item / TWO_POW_16\n        } else if shifts == 3 {\n            item / TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros as u8);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    msg_block[INT_SIZE_PTR] = (len_bytes[0] as u32) << 24\n        | (len_bytes[1] as u32) << 16\n        | (len_bytes[2] as u32) << 8\n        | (len_bytes[3] as u32);\n\n    msg_block[INT_SIZE_PTR + 1] = (len_bytes[4] as u32) << 24\n        | (len_bytes[5] as u32) << 16\n        | (len_bytes[6] as u32) << 8\n        | (len_bytes[7] as u32);\n\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    std::static_assert(\n        INT_SIZE_PTR + 2 == INT_BLOCK_SIZE,\n        \"INT_SIZE_PTR + 2 must equal INT_BLOCK_SIZE\",\n    );\n    let reconstructed_len_hi = msg_block[INT_SIZE_PTR] as Field;\n    let reconstructed_len_lo = msg_block[INT_SIZE_PTR + 1] as Field;\n\n    let reconstructed_len: Field =\n        reconstructed_len_hi * TWO_POW_32 as Field + reconstructed_len_lo;\n    let len = 8 * (message_size as Field);\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\npub(crate) fn finalize_sha256_blocks<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    total_len: u32,\n    mut h: STATE,\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: u32,\n) -> HASH {\n    let modulo = total_len % BLOCK_SIZE;\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    if modulo != 0 {\n        let num_blocks = total_len / BLOCK_SIZE;\n        let msg_start = BLOCK_SIZE * num_blocks;\n        let (new_msg_block, new_msg_byte_ptr) =\n        // Safety: separate verification function\n            unsafe { build_msg_block(msg, message_size, msg_start) };\n\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n        if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n            verify_msg_block_padding(msg_block, msg_byte_ptr);\n        }\n    }\n\n    // If we had modulo == 0 then it means the last block was full,\n    // and we can reset the pointer to zero to overwrite it.\n    if msg_byte_ptr == BLOCK_SIZE {\n        msg_byte_ptr = 0;\n    }\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    let index = msg_byte_ptr / INT_SIZE;\n    msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n    msg_byte_ptr = msg_byte_ptr + 1;\n    let last_block = msg_block;\n\n    // If we don't have room to write the size, compress the block and reset it.\n    if msg_byte_ptr > MSG_SIZE_PTR {\n        h = sha256_compression(msg_block, h);\n\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        msg_byte_ptr = 0;\n    }\n\n    // Safety: separate verification function\n    msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n    verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n\n    hash_final_block(msg_block, h)\n}\n\n/**\n * Given some state of a partially computed sha256 hash and part of the preimage, continue hashing\n * @notice used for complex/ recursive offloading of post-partial hashing\n *\n * @param N - the maximum length of the message to hash\n * @param h - the intermediate hash state\n * @param msg - the preimage to hash\n * @param message_size - the actual length of the preimage to hash\n * @return the intermediate hash state after compressing in msg to h\n */\npub fn partial_sha256_var_interstitial<let N: u32>(\n    mut h: [u32; 8],\n    msg: [u8; N],\n    message_size: u32,\n) -> [u32; 8] {\n    assert(message_size % BLOCK_SIZE == 0, \"Message size must be a multiple of the block size\");\n    if std::runtime::is_unconstrained() {\n        // Safety: running as an unconstrained function\n        unsafe {\n            __sha_partial_var_interstitial(h, msg, message_size)\n        }\n    } else {\n        let (mut h, _, _) = process_full_blocks(msg, message_size, h);\n\n        h\n    }\n}\n\n/**\n * Given some state of a partially computed sha256 hash and remaining preimage, complete the hash\n * @notice used for traditional partial hashing\n *\n * @param N - the maximum length of the message to hash\n * @param h - the intermediate hash state\n * @param msg - the remaining preimage to hash\n * @param message_size - the size of the current chunk\n * @param real_message_size - the total size of the original preimage\n * @return finalized sha256 hash\n */\npub fn partial_sha256_var_end<let N: u32>(\n    mut h: [u32; 8],\n    msg: [u8; N],\n    message_size: u32,\n    real_message_size: u32,\n) -> [u8; 32] {\n    assert(message_size % BLOCK_SIZE == 0, \"Message size must be a multiple of the block size\");\n    if std::runtime::is_unconstrained() {\n        // Safety: running as an unconstrained function\n        unsafe {\n            h = __sha_partial_var_interstitial(h, msg, message_size);\n\n            // Handle setup of the final msg block.\n            // This case is only hit if the msg is less than the block size,\n            // or our message cannot be evenly split into blocks.\n\n            finalize_last_sha256_block(h, real_message_size, msg)\n        }\n    } else {\n        let (mut h, mut msg_block, mut msg_byte_ptr) = process_full_blocks(msg, message_size, h);\n        finalize_sha256_blocks(msg, real_message_size, N, h, msg_block, msg_byte_ptr)\n    }\n}\n\nunconstrained fn __sha_partial_var_interstitial<let N: u32>(\n    mut h: [u32; 8],\n    msg: [u8; N],\n    message_size: u32,\n) -> [u32; 8] {\n    let num_full_blocks = message_size / BLOCK_SIZE;\n    // Intermediate hash, starting with the canonical initial value\n    // Pointer into msg_block on a 64 byte scale\n    for i in 0..num_full_blocks {\n        let (msg_block, _) = build_msg_block(msg, message_size, BLOCK_SIZE * i);\n        h = sha256_compression(msg_block, h);\n    }\n    h\n}\n\nmod equivalence_test {\n\n    #[test]\n    fn test_implementations_agree(msg: [u8; 100], message_size: u64) {\n        let message_size = message_size % 100;\n        // Safety: test function\n        let unconstrained_sha = unsafe { super::__sha256_var(msg, message_size as u32) };\n        let sha = super::sha256_var(msg, message_size);\n        assert_eq(sha, unconstrained_sha);\n    }\n}\n","path":"/Users/felipe/nargo/github.com/noir-lang/sha256/v0.1.5/src/sha256.nr"}},"names":["main"],"brillig_names":["print_unconstrained","build_msg_block","attach_len_to_msg_block","print_unconstrained","build_msg_block","print_unconstrained","build_msg_block","print_unconstrained","directive_invert","directive_integer_quotient","directive_to_radix"]}